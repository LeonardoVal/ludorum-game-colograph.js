{"version":3,"sources":["../src/__prologue__.js","../src/Colograph.js","../src/__epilogue__.js","../src/ui.js","../src/ai.js"],"names":["__init__","base","Sermat","ludorum","declare","obj","raiseIf","copy","raise","Iterable","iterable","Game","exports","players","UserInterface","__package__","__name__","__dependencies__","__SERMAT__","include","Colograph","name","constructor","args","call","this","activePlayer","undefined","initialize","object","defaultValue","array","number","coerce","score","points","shapes","colours","scoreSameShape","scoreDifferentShape","startingPoints","edges","length","forEach","player","n1_edges","n1","n2","k","hasOwnProperty","result","moves","zerosumResult","uncoloured","i","len","push","next","haps","update","move","newColours","Object","assign","adjs","indexOf","opponent","static __SERMAT__","identifier","serializer","edgeColour","node1","node2","connected","colour1","colour2","static randomGraph","nodeCount","edgeCount","random","Math","max","pair","pair2","range","map","split","toArray","n","choice","static randomGame","params","Randomness","DEFAULT","integer","minimum","maximum","subject","randomGraph","randoms","shapeCount","r","games","prototype","circularArrangement","radius","angle","PI","round","cos","sin","gridArrangement","height","width","rows","columns","count","ceil","sqrt","rowHeight","colWidth","floor","playerColour","playerColours","toLowerCase","__svgEnvelope__","source","Array","isArray","join","__svgStyles__","game","p","colour","__svgDefs__","nodeSize","__svgDefCircle__","__svgDefSquare__","__svgDefStar__","__svgDefTriangle__","__svgDefPentagon__","__svgDefHexagon__","__svgDefPolygon__","toSVG","positions","svg","n2s","pos1","pos2","cssClass","pos","heuristics","scoreDifference"],"mappings":"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","file":"ludorum-game-colograph.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\tobj = base.obj,\n\t\tcopy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-colograph',\n\t\t__name__: 'ludorum_game_colograph',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # Colograph\n\nImplementation of the game Colograph, a competitive version of the classic [graph colouring problem](http://en.wikipedia.org/wiki/Graph_coloring).\n*/\nvar Colograph = exports.Colograph = declare(Game, {\n\tname: 'Colograph',\n\n\t/** The constructor takes the following arguments:\n\t*/\n\tconstructor: function Colograph(args) {\n\t\t/** + `activePlayer`: There is only one active player per turn, and it is the first player\n\t\t\tby default.\n\t\t*/\n\t\tGame.call(this, args ? args.activePlayer : undefined);\n\t\tbase.initialize(this, args)\n\t\t/** + `colours`: The colour of each node in the graph is given by an array of integers, each\n\t\t\tbeing the node's player index in the players array, or -1 for uncoloured nodes. By\n\t\t\tdefault all nodes are not coloured, which is the initial game state.\n\t\t*/\n\t\t\t.object('colours', { defaultValue: {} })\n\t\t/** + `edges`: The edges of the graph are represented by an array of arrays of integers,\n\t\t\tacting as an adjacency list.\n\t\t*/\n\t\t\t.array('edges', { defaultValue: [[1,3],[2],[3],[]] })\n\t\t/** + `shapes`: Each of the graph's nodes can have a certain shape. This is specified by an\n\t\t\tarray of strings, one for each node.\n\t\t*/\n\t\t\t.array('shapes', { defaultValue: ['circle', 'triangle', 'square', 'star'] })\n\t\t/** + `scoreSameShape=-1`: Score added by each coloured edge that binds two nodes of the\n\t\t\tsame shape.\n\t\t*/\n\t\t\t.number('scoreSameShape', { defaultValue: -1, coerce: true })\n\t\t/** + `scoreDifferentShape=-1`: Score added by each coloured edge that binds two nodes of\n\t\t\tdifferent shapes.\n\t\t*/\n\t\t\t.number('scoreDifferentShape', { defaultValue: -1, coerce: true });\n\t},\n\n\t/** There are two roles in this game: Red and Blue.\n\t*/\n\tplayers: ['Red', 'Blue'],\n\n\t/** Scores are calculated for each player with the edges of their colour. An edge connecting two\n\tnodes of the same colour is considered to be of that colour.\n\t*/\n\tscore: function score() {\n\t\tvar points = {},\n\t\t\tshapes = this.shapes,\n\t\t\tcolours = this.colours,\n\t\t\tscoreSameShape = this.scoreSameShape,\n\t\t\tscoreDifferentShape = this.scoreDifferentShape,\n\t\t\tstartingPoints = this.edges.length;\n\t\tthis.players.forEach(function (player) {\n\t\t\tpoints[player] = startingPoints;\n\t\t});\n\t\titerable(this.edges).forEach(function (n1_edges, n1) {\n\t\t\tn1_edges.forEach(function (n2) {\n\t\t\t\tvar k = n1 +','+ n2;\n\t\t\t\tif (colours.hasOwnProperty(k)) {\n\t\t\t\t\tpoints[colours[k]] += shapes[n1] === shapes[n2] ? scoreSameShape : scoreDifferentShape;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn points;\n\t},\n\n\t/** The game ends when the active player has no moves, i.e. when all nodes in the graph have\n\tbeen coloured. The match is won by the player with the greatest score.\n\t*/\n\tresult: function result() {\n\t\tif (!this.moves()) { // If the active player cannot move, the game is over.\n\t\t\tvar points = this.score(),\n\t\t\t\tplayers = this.players;\n\t\t\treturn this.zerosumResult(points[players[0]] - points[players[1]], players[0]);\n\t\t} else {\n\t\t\treturn null; // The game continues.\n\t\t}\n\t},\n\n\t/** Every non coloured node is a possible move for the active player.\n\t*/\n\tmoves: function moves() {\n\t\tvar colours = this.colours,\n\t\t\tuncoloured = [];\n\t\tfor (var i = 0, len = this.edges.length; i < len; i++) {\n\t\t\tif (!colours.hasOwnProperty(i)) {\n\t\t\t\tuncoloured.push(i);\n\t\t\t}\n\t\t}\n\t\treturn uncoloured.length < 1 ? null : obj(this.activePlayer(), uncoloured);\n\t},\n\n\t/** The result of any move is the colouring of one previously uncoloured node with the active\n\tplayers's colour.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar activePlayer = this.activePlayer(),\n\t\t\tmove = moves[activePlayer] |0;\n\t\traiseIf(move < 0 || move >= this.edges.length,\n\t\t\t'Invalid move: node ', move, ' does not exist in ', this, '.');\n\t\traiseIf(this.colours.hasOwnProperty(move),\n\t\t\t'Invalid move: node ', move, ' has already been coloured in ', this, '.');\n\t\tvar newColours = Object.assign(obj(move, activePlayer), this.colours);\n\t\tthis.edges[move].forEach(function (n2) { // Colour edges from the one coloured in this move.\n\t\t\tif (newColours[n2] === activePlayer) {\n\t\t\t\tnewColours[move +','+ n2] = activePlayer;\n\t\t\t}\n\t\t});\n\t\tthis.edges.forEach(function (adjs, n1) { // Colour edges to the one coloured in this move.\n\t\t\tif (n1 !== move && adjs.indexOf(move) >= 0 && newColours[n1] === activePlayer) {\n\t\t\t\tnewColours[n1 +','+ move] = activePlayer;\n\t\t\t}\n\t\t});\n\t\tvar args = {\n\t\t\tactivePlayer: this.opponent(activePlayer),\n\t\t\tcolours: newColours,\n\t\t\tedges: this.edges,\n\t\t\tshapes: this.shapes,\n\t\t\tscoreSameShape: this.scoreSameShape,\n\t\t\tscoreDifferentShape: this.scoreDifferentShape\n\t\t};\n\t\tif (update) {\n\t\t\tthis.constructor(args);\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(args);\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** Serialization is used in the `toString()` method, but it is also vital for sending the game\n\tstate across a network or the marshalling between the rendering thread and a webworker.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Colograph',\n\t\tserializer: function serialize_Colograph(obj) {\n\t\t\treturn [{\n\t\t\t\tactivePlayer: obj.activePlayer(),\n\t\t\t\tcolours: obj.colours,\n\t\t\t\tedges: obj.edges,\n\t\t\t\tshapes: obj.shapes,\n\t\t\t\tscoreSameShape: obj.scoreSameShape,\n\t\t\t\tscoreDifferentShape: obj.scoreDifferentShape\n\t\t\t}];\n\t\t}\n\t},\n\n\t// ## Game properties. #########################################################################\n\n\t/** `edgeColour(node1, node2)` returns a colour (player index) if the nodes are joined by an\n\tedge, and both have that same colour.\n\t*/\n\tedgeColour: function edgeColour(node1, node2) {\n\t\tvar connected = this.edges[node1].indexOf(node2) >= 0 || this.edges[node2].indexOf(node1) >= 0,\n\t\t\tcolour1 = this.colours[node1],\n\t\t\tcolour2 = this.colours[node2];\n\t\treturn connected && colour1 >= 0 && colour1 === colour2 ? colour1 : -1;\n\t},\n\n\t// ## Graph generation. ########################################################################\n\n\t/** One of the nice features of this game is the variety that comes from chaning the graph on\n\twhich the game is played. `randomGraph` can be used to generate graphs to experiment with.\n\t*/\n\t'static randomGraph': function randomGraph(nodeCount, edgeCount, random) {\n\t\tnodeCount = Math.max(2, +nodeCount >> 0);\n\t\tedgeCount = Math.max(nodeCount - 1, +edgeCount >> 0);\n\t\tvar edges = Iterable.range(nodeCount - 1).map(function (i) {\n\t\t\treturn random.split(1, Iterable.range(i + 1, nodeCount).toArray());\n\t\t}).toArray();\n\t\tfor (var n = edgeCount - (nodeCount - 1), pair, pair2; n > 0; n--) {\n\t\t\tpair = random.choice(edges);\n\t\t\tif (pair[1].length > 0) {\n\t\t\t\tpair2 = random.split(1, pair[1]);\n\t\t\t\tpair[0].push(pair2[0][0]);\n\t\t\t\tpair[1] = pair2[1];\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tedges = edges.map(function (pair) {\n\t\t\treturn pair[0];\n\t\t});\n\t\tedges.push([]); // Last node has no edges.\n\t\treturn edges;\n\t},\n\n\t/** `randomGame(params)` will generates a random Colograph game with a random graph.\n\t*/\n\t'static randomGame': function randomGame(params) {\n\t\tparams = base.initialize({}, params)\n\t\t\t.object('random', { defaultValue: base.Randomness.DEFAULT })\n\t\t\t.integer('nodeCount', { defaultValue: 8, coerce: true })\n\t\t\t.integer('edgeCount', { defaultValue: 11, coerce: true })\n\t\t\t.integer('shapeCount', { defaultValue: 4, coerce: true, minimum: 1, maximum: 4 })\n\t\t\t.array('shapes', { defaultValue: ['circle', 'triangle', 'square', 'star'] })\n\t\t\t.subject;\n\t\treturn new this({\n\t\t\tedges: this.randomGraph(params.nodeCount, params.edgeCount, params.random),\n\t\t\tshapes: params.random.randoms(params.nodeCount, 0, params.shapeCount).map(function (r) {\n\t\t\t\treturn params.shapes[r|0];\n\t\t\t}),\n\t\t\tscoreSameShape: 1\n\t\t});\n\t}\n}); // declare Colograph.\n\n/** Adding Colograph to `ludorum.games`.\n*/\nludorum.games.Colograph = Colograph;\n\n/** Sermat serialization.\n*/\nColograph.__SERMAT__.identifier = exports.__package__ +'.'+ Colograph.__SERMAT__.identifier;\nexports.__SERMAT__.include.push(Colograph);\nSermat.include(exports);\n","// See __prologue__.js\n\treturn exports;\n}\n","/** # User interface\n\nThe user interface for playtesters is based on [SVG](https://www.w3.org/TR/SVG/).\n*/\n\nObject.assign(Colograph.prototype, {\n\n/** Nodes in the `Colograph` object do not have a defined position. Yet they must be given one if\nthe board is going to be rendered properly. This _arrangement_ methods calculate an array of\npositions for every node in the game, follwing different criteria:\n\n\t+ `circularArrangement` puts all nodes in a circle of a given `radius`.\n*/\n\tcircularArrangement: function circularArrangement(radius) {\n\t\tradius = radius || 200;\n\t\tvar angle = 2 * Math.PI / this.edges.length;\n\t\treturn this.edges.map(function (adjs, n) {\n\t\t\treturn [Math.round(radius * Math.cos(angle * n)),\n\t\t\t\tMath.round(radius * Math.sin(angle * n))];\n\t\t});\n\t},\n\n/**\t+ `gridArrangement` puts nodes in the vertices of a grid with given numbers of `rows` and\n\t`columns`.\n */\n \tgridArrangement: function gridArrangement(height, width, rows, columns) {\n\t\theight = height || 400;\n\t\twidth = width || 400;\n\t\tvar count = this.edges.length;\n\t\tif (!columns) {\n\t\t\tif (!rows) {\n\t\t\t\trows = Math.ceil(Math.sqrt(count));\n\t\t\t}\n\t\t\tcolumns = Math.ceil(count / rows);\n\t\t}\n\t\tvar rowHeight = height / (rows - 1),\n\t\t\tcolWidth = width / (columns - 1);\n\t\treturn this.edges.map(function (adjs, n) {\n\t\t\treturn [\n\t\t\t\t(n % columns) * colWidth - width / 2,\n\t\t\t\tMath.floor(n / columns) * rowHeight - height / 2\n\t\t\t];\n\t\t});\n\t},\n\n\t//TODO More arrangement options.\n\n/** Each player in the game represents a `playerColour`. If the game state has a `playerColours`\nproperty defined, it is assumed it maps players with CSS colour names. Else the players' names in\nlowercase are used as CSS colour names.\n*/\n\tplayerColour: function (player, playerColours) {\n\t\tplayerColours = playerColours || this.playerColours;\n\t\treturn playerColours && playerColours[player] ||\n\t\t\tplayer && (player +'').toLowerCase() || '';\n\t},\n\n/** ## SVG #########################################################################################\n\nThese function implement the generation of Colograph game interfaces based on [Scalable Vector\nGraphics (a.k.a. SVG)](https://www.w3.org/TR/SVG/).\n*/\n\n/** The _envelope_ of the SVG definitions include the processing instruction (`<?xml ... ?>`), the\nSVG's DOCTYPE and the root element `svg`. The `xlink` namespace is used in the `use` elements.\n*/\n\t__svgEnvelope__: function __svgEnvelope__(width, height, source) {\n\t\treturn '<?xml version=\"1.0\" standalone=\"no\"?>\\n'+\n\t\t\t'<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" '+\n\t\t\t\t'\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n'+\n\t\t\t'<svg height=\"'+ height +'px\" width=\"'+ width +'px\" version=\"1.1\"\\n'+\n\t\t\t\t'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\\n'+\n\t\t\t(Array.isArray(source) ? source.join('\\n\\t') : source) +\n\t\t\t'\\n</svg>';\n\t},\n\n/** The generated SVG for a Colograph game uses CSS styles as much as possible. Two style are\ndefined for each player and the blank state, one for edges and one for nodes.\n*/\n\t__svgStyles__: function __svgStyles__(playerColours) {\n\t\tvar game = this;\n\t\treturn '<style type=\"text/css\" ><![CDATA[\\n'+\n\t\t\t'\\t.blank-node { stroke:black; stroke-width:2px; fill:white; }\\n'+\n\t\t\t'\\t.blank-node:hover { stroke-width:4px; }\\n'+\n\t\t\t'\\t.blank-edge { stroke:black; stroke-width:2px; }\\n'+\n\t\t\tthis.players.map(function (p) { // Embedded CSS Styles\n\t\t\t\tvar colour = game.playerColour(p, playerColours);\n\t\t\t\treturn '\\t.'+ colour +'-node { stroke:black; stroke-width:2px; fill:'+ colour +\n\t\t\t\t\t'}\\n\\t.'+\tcolour +'-edge { stroke:'+ colour +'; stroke-width:2px }';\n\t\t\t}).join('\\n') +\n\t\t\t'\\t]]>\\n\\t</style>\\n';\n\t},\n\n/** All possible node shapes are defined in a `defs` element, so they can be reused. A translate\ntransform is used to put each node in its corresponding possition. Still, `nodeSize` has to be\nprovided, since scaling may lead to weird results.\n*/\n\t__svgDefs__: function __svgDefs__(nodeSize) {\n\t\tnodeSize = nodeSize || 30;\n\t\treturn ['<defs>',\n\t\t\tthis.__svgDefCircle__(nodeSize),\n\t\t\tthis.__svgDefSquare__(nodeSize),\n\t\t\tthis.__svgDefStar__(nodeSize),\n\t\t\tthis.__svgDefTriangle__(nodeSize),\n\t\t\tthis.__svgDefPentagon__(nodeSize),\n\t\t\tthis.__svgDefHexagon__(nodeSize),\n\t\t\t'</defs>'\n\t\t].join('\\n');\n\t},\n\n/** Some of the available shapes are defined as polygons, given the `points` of their vertices.\nThese points are multiplied by `nodeSize`, hence the shape they defined must be centered at (0,0)\nand must have a size of 1.\n*/\n\t__svgDefPolygon__: function __svgDefPolygon__(name, points, nodeSize) {\n\t\tpoints = points.map(function (p) {\n\t\t\treturn [p[0] * nodeSize, p[1] * nodeSize];\n\t\t});\n\t\treturn '\\t<polygon id=\"'+ name +'-node\" points=\"'+ points.join(' ') +'\"/>';\n\t},\n\n/** Available shapes are:\n\t+ `circle`,\n*/\n\t__svgDefCircle__: function __svgDefCircle__(nodeSize) {\n\t\treturn '\\t<circle id=\"circle-node\" r=\"'+ (nodeSize / 2) +'px\" cx=\"0\" cy=\"0\"/>';\n\t},\n\n/** + `square`,\n*/\n\t__svgDefSquare__: function __svgDefSquare__(nodeSize) {\n\t\treturn '\\t<rect id=\"square-node\" width=\"'+ nodeSize +'px\" height=\"'+ nodeSize +'px\"'+\n\t\t\t' x=\"-'+ (nodeSize / 2) +'\" y=\"-'+ (nodeSize / 2) +'\"/>';\n\t},\n\n/** + `triangle` (equilateral),\n*/\n\t__svgDefTriangle__: function __svgDefTriangle__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('triangle', [\n\t\t\t\t[-0.50,+0.44], [+0.00,-0.44], [+0.50,+0.44]\n\t\t\t], nodeSize);\n\t},\n\n/** + `star` (five points),\n*/\n\t__svgDefStar__: function __svgDefStar__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('star', [\n\t\t\t\t[+0.00,-0.48], [+0.12,-0.10], [+0.50,-0.10], [+0.20,+0.10], [+0.30,+0.48],\n\t\t\t\t[+0.00,+0.26], [-0.30,+0.48], [-0.20,+0.10], [-0.50,-0.10], [-0.12,-0.10]\n\t\t\t], nodeSize);\n\t},\n\n/** + `pentagon` (regular),\n*/\n\t__svgDefPentagon__: function __svgDefPentagon__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('pentagon', [\n\t\t\t\t[+0.00,-0.48], [+0.50,-0.10], [+0.30,+0.48], [-0.30,+0.48], [-0.50,-0.10]\n\t\t\t], nodeSize);\n\t},\n\n/** + `hexagon` (regular),\n*/\n\t__svgDefHexagon__: function __svgDefHexagon__(nodeSize) {\n\t\treturn this.__svgDefPolygon__('pentagon', [\n\t\t\t\t[+0.00,-0.50], [+0.42,-0.24], [+0.42,+0.24], [+0.00,+0.50], [-0.42,+0.24],\n\t\t\t\t[-0.42,-0.24]\n\t\t\t], nodeSize);\n\t},\n\n/** The method `toSVG` generates the SVG representation of a Colograph game state.\n*/\n\ttoSVG: function toSVG(width, height, nodeSize, positions) {\n\t\twidth = width || 400;\n\t\theight = height || 400;\n\t\t//positions = positions || this.circularArrangement(Math.max(width, height) / 2.4);\n\t\tpositions = positions || this.gridArrangement(width * 0.8, height * 0.8);\n\t\tvar game = this,\n\t\t\tcolours = this.colours,\n\t\t \tsvg = [\n\t\t\t\tthis.__svgStyles__(),\n\t\t\t\tthis.__svgDefs__(nodeSize),\n\t\t\t\t'\\t<g id=\"colograph\" transform=\"translate('+ (width / 2) +','+ (height / 2) +')\">'\n\t\t\t];\n\t\t/** Edges are drawn before the nodes, so they do not appear in front of them.\n\t\t*/\n\t\tthis.edges.forEach(function (n2s, n1) {\n\t\t\tvar pos1 = positions[n1];\n\t\t\tn2s.forEach(function (n2) {\n\t\t\t\tvar pos2 = positions[n2],\n\t\t\t\t\tcolour = colours[n1 +','+ n2],\n\t\t\t\t\tcssClass = (game.playerColour(colour) || 'blank') +'-edge';\n\t\t\t\tsvg.push('\\t<line class=\"'+ cssClass +'\" x1=\"'+ pos1[0] +'\" y1=\"'+ pos1[1] +\n\t\t\t\t\t'\" x2=\"'+ pos2[0] +'\" y2=\"'+ pos2[1] +'\"/>');\n\t\t\t});\n\t\t});\n\t\t/** Node shapes reuse the definitions generated before, and are put in place with a\n\t\ttranslation transform.\n\t\t*/\n\t\tvar shapes = this.shapes;\n\t\tthis.edges.forEach(function (adjs, n) {\n\t\t\tvar pos = positions[n],\n\t\t\t\tcolour = colours[n],\n\t\t\t\tcssClass = (game.playerColour(colour) || 'blank') +'-node';\n\t\t\tsvg.push('<use id=\"node'+ n +'\" xlink:href=\"#'+ shapes[n] +'-node\" '+\n\t\t\t\t'transform=\"translate('+ pos.join(',') +')\" class=\"'+ cssClass +'\" '+\n\t\t\t\t'data-ludorum-move=\"'+ n +'\"/>');\n\t\t});\n\t\tsvg.push('\\t</g>');\n\t\treturn this.__svgEnvelope__(width, height, svg);\n\t} // Colograph.toSVG\n}); //\n","// # AI for Colograph.\n\n// ## Heuristics ###################################################################################\n\n/** `heuristics` is a namespace for heuristic evaluation functions to be used with artificial\nintelligence methods such as Minimax.\n*/\nColograph.heuristics = {\n\t/** `scoreDifference(game, player)` is a simple heuristic that uses the current score.\n\t*/\n\tscoreDifference: function scoreDifference(game, player) {\n\t\tvar score = game.score(),\n\t\t\tresult = 0;\n\t\tfor (var p in score) {\n\t\t\tresult += p === player ? score[p] : -score[p];\n\t\t}\n\t\treturn result / game.edges.length / 2;\n\t}\n}; // Colograph.heuristics\n"]}